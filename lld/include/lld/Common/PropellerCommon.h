#ifndef LLD_ELF_PROPELLER_COMMON_H
#define LLD_ELF_PROPELLER_COMMON_H

#include "llvm/ADT/SmallVector.h"
#include "llvm/ADT/StringRef.h"
#include "llvm/Object/ObjectFile.h"

#include <string>

using llvm::SmallVector;
using llvm::StringRef;

namespace lld {
namespace propeller {

static const char BASIC_BLOCK_SEPARATOR[] = ".BB.";
static const char BASIC_BLOCK_UNIFIED_CHARACTERS[] = "arlL";

// This data structure is shared between lld propeller components and
// create_llvm_prof. In short, create_llvm_prof parses the binary, wraps all the
// symbol information using SymbolEntry class, whereas in Propeller, PropFile
// class parses the propeller profile (which is generated by create_llvm_prof),
// and wraps the symbol information in SymbolEntry. In other words, SymbolEntry
// is the interface shared between create_llvm_prof and Propeller.
// [create_llvm_prof refer to:
// https://github.com/shenhanc78/autofdo/tree/plo-dev]
struct SymbolEntry {
  enum BBTagTypeEnum : unsigned char {
    BB_NONE = 0,              // For functions.
    BB_NORMAL,                // Ordinary BB, 'a'.
    BB_RETURN,                // Return BB, 'r'.
    BB_LANDING_PAD,           // Landing pad BB, 'l'.
    BB_RETURN_AND_LANDING_PAD // Landing pad and return BB, 'L'.
  };

  using AliasesTy = SmallVector<StringRef, 3>;

  SymbolEntry(uint64_t O, const StringRef &N, AliasesTy &&As, uint64_t A,
              uint64_t S, uint8_t T, bool BB = false,
              SymbolEntry *FuncPtr = nullptr)
      : ordinal(O), name(N), aliases(As), addr(A), size(S), type(T), bBTag(BB),
        bBTagType(BB_NONE), hotTag(false), containingFunc(FuncPtr) {}

  // Unique index number across all symbols that participate linking.
  uint64_t ordinal;
  // For a function symbol, it's the full name. For a bb symbol this is only the
  // bbindex part, which is the number of "a"s before the ".bb." part. For
  // example "8", "10", etc. Refer to Propfile::createFunctionSymbol and
  // Propfile::createBasicBlockSymbol.
  StringRef name;
  // Only valid for function (bBTag == false) symbols. And aliases[0] always
  // equals to name. For example, SymbolEntry.name = "foo", SymbolEntry.aliases
  // = {"foo", "foo2", "foo3"}.
  AliasesTy aliases;
  uint64_t addr;
  uint64_t size;
  uint8_t type; // Of type: llvm::objet::SymbolRef::type.
  bool bBTag;   // Whether this is a basic block section symbol.
  BBTagTypeEnum bBTagType;

  bool hotTag; // Whether this symbol is listed in the propeller section.
  // For bBTag symbols, this is the containing fuction pointer, for a normal
  // function symbol, this points to itself. This is neverl nullptr.
  SymbolEntry *containingFunc;

  bool isReturnBlock() const {
    return bBTagType == BB_RETURN || bBTagType == BB_RETURN_AND_LANDING_PAD;
  }

  bool isLandingPadBlock() const {
    return bBTagType == BB_LANDING_PAD ||
           bBTagType == BB_RETURN_AND_LANDING_PAD;
  }

  bool operator<(const SymbolEntry &Other) const {
    return this->ordinal < Other.ordinal;
  }

  bool isFunction() const {
    return type == llvm::object::SymbolRef::ST_Function;
  }

  // Return true if "SymName" is a BB symbol, e.g., in the form of
  // "a.BB.funcname", and set FuncName to the part after ".BB.", BBIndex to
  // before ".BB.", if the pointers are nonnull.
  static bool isBBSymbol(const StringRef &SymName,
                         StringRef *FuncName = nullptr,
                         StringRef *BBIndex = nullptr) {
    if (SymName.empty())
      return false;
    auto R = SymName.split(BASIC_BLOCK_SEPARATOR);
    if (R.second.empty())
      return false;
    for (auto *I = R.first.bytes_begin(), *J = R.first.bytes_end(); I != J; ++I)
      if (strchr(BASIC_BLOCK_UNIFIED_CHARACTERS, *I) == NULL)
        return false;
    if (FuncName)
      *FuncName = R.second;
    if (BBIndex)
      *BBIndex = R.first;
    return true;
  }

  static BBTagTypeEnum toBBTagType(const char c) {
    switch (c) {
    case 'a':
      return BB_NORMAL;
    case 'r':
      return BB_RETURN;
    case 'l':
      return BB_LANDING_PAD;
    case 'L':
      return BB_RETURN_AND_LANDING_PAD;
    default:
      assert(false);
    }
    return BB_NONE;
  }

  static const uint64_t INVALID_ADDRESS = uint64_t(-1);
};

struct SymbolEntryOrdinalLessComparator {
  bool operator()(SymbolEntry *s1, SymbolEntry *s2) const {
    if (s1 && s2)
      return s1->ordinal < s2->ordinal;
    return !!s1 < !!s2;
  }
};

} // namespace propeller
} // namespace lld
#endif
