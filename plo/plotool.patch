diff --git a/Makefile.am b/Makefile.am
index a6b8e0f..2c3c7c3 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -78,7 +78,7 @@ $(am_profile_update_OBJECTS): $(protoc_outputs)
 
 bin_PROGRAMS += create_llvm_prof
 create_llvm_prof_SOURCES = $(COMMON_PROFILE_CREATOR_FILES) \
-                           llvm_profile_writer.cc create_llvm_prof.cc
+                           llvm_profile_writer.cc create_llvm_prof.cc llvm_plo_profile_writer.cc
 create_llvm_prof_LDADD = $(LLVM_LDFLAGS) $(LLVM_LIBS) libquipper.a libglog.a \
                          libsymbolize.a libgflags.a $(LIBELF) $(PROTOBUF_DEP)
 create_llvm_prof_CXXFLAGS = $(LLVM_CXXFLAGS) -DCREATE_LLVM_PROF
diff --git a/configure.ac b/configure.ac
index 7f5cc3a..d59d605 100644
--- a/configure.ac
+++ b/configure.ac
@@ -22,7 +22,7 @@ AC_PROG_CC
 AC_PROG_RANLIB
 
 AX_CXX_COMPILE_STDCXX_11
-AX_LLVM([ProfileData])
+AX_LLVM([Object ProfileData Support])
 
 ac_cv_have_libgflags=1
 AC_DEFINE(HAVE_LIB_GFLAGS, 1, [define if you have google gflags library])
diff --git a/create_llvm_prof.cc b/create_llvm_prof.cc
index 87b50f5..543f494 100644
--- a/create_llvm_prof.cc
+++ b/create_llvm_prof.cc
@@ -22,6 +22,8 @@
 #include "gflags/gflags.h"
 #include "profile_creator.h"
 #include "llvm_profile_writer.h"
+#include "llvm_plo_profile_writer.h"
+
 
 DEFINE_string(profile, "perf.data", "Input profile file name");
 DEFINE_string(profiler, "perf",
@@ -34,7 +36,7 @@ DEFINE_string(gcov, "",
 DEFINE_string(binary, "a.out", "Binary file name");
 DEFINE_string(format, "binary",
               "LLVM profile format to emit. Possible values are 'text' or "
-              "'binary'. The binary format is a more compact representation, "
+              "'binary' or 'plo'. The binary format is a more compact representation, "
               "but the text format is human readable and more likely to be "
               "compatible with older versions of LLVM.");
 
@@ -49,6 +51,40 @@ int main(int argc, char **argv) {
   google::ParseCommandLineFlags(&argc, &argv, true);
   google::InitGoogleLogging(argv[0]);
 
+/*
+  quipper::PerfReader PR;
+  if (!PR.ReadFile(FLAGS_profile)) {
+    fprintf(stderr, "Failed to open: %s.\n", FLAGS_profile.c_str());
+    return 1;
+  }
+
+  quipper::PerfParser Parser(&PR);
+  if (!Parser.ParseRawEvents()) {
+    fprintf(stderr, "failed to parse raw events.\n");
+    return 1;
+  }
+
+  int i = 0;
+  for (const auto &PE: Parser.parsed_events()) {
+    // fprintf(stderr, "Branch stack size: %lu\n", PE.branch_stack.size());
+    // fprintf(stderr, "DSO name: %s\n", PE.dso_and_offset.dso_name().c_str());
+    quipper::PerfDataProto_PerfEvent *EPtr = PE.event_ptr;
+    if (EPtr->event_type_case() == quipper::PerfDataProto_PerfEvent::kMmapEvent) {
+      const quipper::PerfDataProto_MMapEvent &MM = EPtr->mmap_event();
+      fprintf(stderr, "pid/filename: %lu, %s, 0x%lx\n", MM.pid(), MM.has_filename() ? MM.filename().c_str() : "", MM.has_start() ? MM.start(): 0);
+    }
+    if (++i == 500000) {
+      break;
+    }
+  }
+
+  return 0;*/
+
+  PLOProfileWriter PPWriter(FLAGS_binary, FLAGS_profile);
+  PPWriter.populateSymbolMap();
+  PPWriter.parsePerfData();
+  return 1;
+
   // If the user specified --gcov instead of --out, use that value.
   // If both are used, they must match.
   if (!FLAGS_gcov.empty()) {
@@ -71,6 +107,8 @@ int main(int argc, char **argv) {
     writer.reset(new autofdo::LLVMProfileWriter(llvm::sampleprof::SPF_Text));
   } else if (FLAGS_format == "binary") {
     writer.reset(new autofdo::LLVMProfileWriter(llvm::sampleprof::SPF_Binary));
+  } else if (FLAGS_format == "plo") {
+
   } else {
     LOG(ERROR) << "--format must be one of 'text' or 'binary'";
     return 1;
diff --git a/llvm_plo_profile_writer.cc b/llvm_plo_profile_writer.cc
new file mode 100644
index 0000000..8a38df4
--- /dev/null
+++ b/llvm_plo_profile_writer.cc
@@ -0,0 +1,133 @@
+#include "config.h"
+#if defined(HAVE_LLVM)
+#include "llvm_plo_profile_writer.h"
+
+#include <functional>
+#include <string>
+
+#include "llvm/ADT/StringRef.h"
+#include "llvm/Object/ELFObjectFile.h"
+#include "llvm/Object/ObjectFile.h"
+#include "llvm/Support/MemoryBuffer.h"
+#include "llvm/Support/Path.h"
+
+#include "third_party/perf_data_converter/src/quipper/perf_parser.h"
+
+using llvm::MemoryBuffer;
+using llvm::MemoryBufferRef;
+using llvm::object::ELFSymbolRef;
+using llvm::object::SymbolRef;
+using llvm::StringRef;
+using std::string;
+
+PLOProfileWriter::PLOProfileWriter(const string &BFN, const string &PFN)
+    : BinaryFileName(BFN), PerfFileName(PFN) {}
+
+PLOProfileWriter::~PLOProfileWriter() {}
+
+bool PLOProfileWriter::populateSymbolMap() {
+    auto FileOrError = llvm::MemoryBuffer::getFile(StringRef(this->BinaryFileName));
+    if (!FileOrError)
+        return false;
+    this->BinaryFileContent = std::move(*FileOrError);
+
+    auto Result = llvm::object::ObjectFile::createELFObjectFile(
+        MemoryBufferRef(*(this->BinaryFileContent)));
+    if (!Result) {
+        return false;
+    }
+    this->ObjectFile = std::move(*Result);
+
+    auto Symbols = ObjectFile->symbols();
+    for (const SymbolRef &Sym : Symbols) {
+        auto AddrR = Sym.getAddress();
+        if (AddrR && *AddrR) {
+            auto SecR = Sym.getSection();
+            if (SecR && (*SecR)->isText()) {
+                SymbolMap[*AddrR].emplace_back(Sym);
+            }
+        }
+    }
+
+    for (auto &T : SymbolMap) {
+        fprintf(stderr, "0x%lx:", T.first);
+        for (auto &Sym: T.second) {
+            auto NameR = Sym.getName();
+            fprintf(stderr, " %s", NameR ? NameR->str().c_str() : "");
+        }
+        fprintf(stderr, "\n");
+    }
+    return true;
+}
+
+// MMapFileName is always absolute.
+static bool BinaryMatchesMMapFileNameAbsolute(
+    const string &AbsoluteBinaryFileName,
+    const string &MMapFileName) {
+    return AbsoluteBinaryFileName == MMapFileName;
+}
+
+// MMapFileName is always absolute.
+static bool BinaryMatchesMMapFileNameRelative(
+    const string &BinaryFileNameWithoutPath,
+    const string &MMapFileName) {
+    return BinaryFileNameWithoutPath == llvm::sys::path::filename(MMapFileName);
+}
+
+bool PLOProfileWriter::parsePerfData() {
+    quipper::PerfReader PR;
+    if (!PR.ReadFile(PerfFileName)) {
+        LOG(ERROR) << "Failed to read perf data file: " << PerfFileName;
+        return false;
+    }
+
+    quipper::PerfParser Parser(&PR);
+    if (!Parser.ParseRawEvents()) {
+        LOG(ERROR) << "Failed to parse perf raw events.";
+        return false;
+    }
+
+    // Depends on the binary file name, if
+    //   it is absolute, compares it agains the full path
+    //   it is relative, only compares the file name part.
+    std::function<bool(const string&)> CompFunc;
+    if (llvm::sys::path::is_absolute(BinaryFileName)) {
+        CompFunc = std::bind(BinaryMatchesMMapFileNameAbsolute,
+                             BinaryFileName,
+                             std::placeholders::_1);
+    } else {
+        CompFunc = std::bind(BinaryMatchesMMapFileNameRelative,
+                             llvm::sys::path::filename(BinaryFileName),
+                             std::placeholders::_1);
+    }
+
+    for (const auto &PE: Parser.parsed_events()) {
+        quipper::PerfDataProto_PerfEvent *EPtr = PE.event_ptr;
+        if (EPtr->event_type_case() == quipper::PerfDataProto_PerfEvent::kMmapEvent) {
+            const quipper::PerfDataProto_MMapEvent &MMap = EPtr->mmap_event();
+            if (MMap.has_filename()) {
+                const string &MMapFileName = MMap.filename();
+                if (CompFunc(MMapFileName) && MMap.has_start() && MMap.has_len()) {
+                    if (BinaryLoadAddr == InvalidAddress) {
+                        BinaryLoadAddr = MMap.start();
+                        BinaryLoadSize = MMap.len();
+                    } else if (BinaryLoadAddr != MMap.start() ||
+                        BinaryLoadSize != MMap.len()) {
+                        LOG(ERROR) << "Same binary has different MMAP entries.";
+                    }
+                }
+            }
+        }
+    }
+
+    if (this->BinaryLoadAddr == InvalidAddress) {
+        LOG(ERROR) << "Failed to find mmap entry in perf data, is '"
+            << BinaryFileName << "' correct?";
+    }
+
+    fprintf(stderr, "Mapped to: 0x%lx(0x%lx)\n", BinaryLoadAddr, BinaryLoadSize);
+    return true;
+}
+
+#endif
+
diff --git a/llvm_plo_profile_writer.h b/llvm_plo_profile_writer.h
new file mode 100644
index 0000000..d98f08a
--- /dev/null
+++ b/llvm_plo_profile_writer.h
@@ -0,0 +1,51 @@
+#include "config.h"
+#if defined(HAVE_LLVM)
+#ifndef _LLVM_PLO_PROFILE_WRITER_H_
+#define _LLVM_PLO_PROFILE_WRITER_H_
+
+#include <list>
+#include <map>
+#include <memory>
+#include <string>
+
+#include "llvm/Object/ELFObjectFile.h"
+#include "llvm/Object/ObjectFile.h"
+#include "llvm/Support/MemoryBuffer.h"
+
+using std::list;
+using std::map;
+using std::string;
+using std::unique_ptr;
+
+using llvm::MemoryBuffer;
+using llvm::object::ELFSymbolRef;
+using llvm::object::ObjectFile;
+
+class PLOProfileWriter {
+
+public:
+    PLOProfileWriter(const string &BFN, const string &PFN);
+    ~PLOProfileWriter();
+
+    bool populateSymbolMap();
+    bool parsePerfData();
+
+private:
+    const string BinaryFileName;
+    const string PerfFileName;
+
+    // Note: BinaryFileContent must be the last one to be destroyed.
+    // So it must appear first in this section.
+    unique_ptr<MemoryBuffer>          BinaryFileContent;
+    unique_ptr<ObjectFile>            ObjectFile;
+    map<uint64_t, list<ELFSymbolRef>> SymbolMap;
+
+    uint64_t BinaryLoadAddr{InvalidAddress};
+    uint64_t BinaryLoadSize{InvalidAddress};
+
+    static const uint64_t InvalidAddress{uint64_t(-1)};
+};
+
+#endif
+#endif
+
