; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -indvars -S | FileCheck %s

; PR31181: It may be necessary to drop nuw/nsw flags when moving from a
; pre-increment comparison to a post-increment comparison.

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"

@a = global i32 0

define i32 @test_drop_nuw() {
; CHECK-LABEL: @test_drop_nuw(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[STOREMERGE:%.*]] = phi i32 [ -2, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[LOOP]] ]
; CHECK-NEXT:    store i32 [[STOREMERGE]], i32* @a
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[STOREMERGE]], 1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp ne i32 [[INC]], 0
; CHECK-NEXT:    br i1 [[EXITCOND]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    ret i32 0
;
entry:
  br label %loop

loop:
  %storemerge = phi i32 [ -2, %entry ], [ %inc, %loop ]
  store i32 %storemerge, i32* @a
  %cmp = icmp slt i32 %storemerge, -1
  %inc = add nuw nsw i32 %storemerge, 1
  br i1 %cmp, label %loop, label %exit

exit:
  ret i32 0
}

define i32 @test_drop_nsw() {
; CHECK-LABEL: @test_drop_nsw(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[STOREMERGE:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[LOOP]] ]
; CHECK-NEXT:    store i32 [[STOREMERGE]], i32* @a
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[STOREMERGE]], 1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp ne i32 [[INC]], -2147483648
; CHECK-NEXT:    br i1 [[EXITCOND]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    ret i32 0
;
entry:
  br label %loop

loop:
  %storemerge = phi i32 [ 0, %entry ], [ %inc, %loop ]
  store i32 %storemerge, i32* @a
  %cmp = icmp ult i32 %storemerge, 2147483647
  %inc = add nuw nsw i32 %storemerge, 1
  br i1 %cmp, label %loop, label %exit

exit:
  ret i32 0
}

define i32 @test_no_drop_nuw() {
; CHECK-LABEL: @test_no_drop_nuw(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[STOREMERGE:%.*]] = phi i32 [ -3, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[LOOP]] ]
; CHECK-NEXT:    store i32 [[STOREMERGE]], i32* @a
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[STOREMERGE]], 1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp ne i32 [[INC]], -1
; CHECK-NEXT:    br i1 [[EXITCOND]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    ret i32 0
;
entry:
  br label %loop

loop:
  %storemerge = phi i32 [ -3, %entry ], [ %inc, %loop ]
  store i32 %storemerge, i32* @a
  %cmp = icmp slt i32 %storemerge, -2
  %inc = add nuw nsw i32 %storemerge, 1
  br i1 %cmp, label %loop, label %exit

exit:
  ret i32 0
}


define i32 @test_no_drop_nsw() {
; CHECK-LABEL: @test_no_drop_nsw(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[STOREMERGE:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[LOOP]] ]
; CHECK-NEXT:    store i32 [[STOREMERGE]], i32* @a
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[STOREMERGE]], 1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp ne i32 [[INC]], 2147483647
; CHECK-NEXT:    br i1 [[EXITCOND]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    ret i32 0
;
entry:
  br label %loop

loop:
  %storemerge = phi i32 [ 0, %entry ], [ %inc, %loop ]
  store i32 %storemerge, i32* @a
  %cmp = icmp ult i32 %storemerge, 2147483646
  %inc = add nuw nsw i32 %storemerge, 1
  br i1 %cmp, label %loop, label %exit

exit:
  ret i32 0
}

define i32 @test_drop_nsw_var_lim(i32 %lim) {
; CHECK-LABEL: @test_drop_nsw_var_lim(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[C:%.*]] = icmp ult i32 [[LIM:%.*]], -1
; CHECK-NEXT:    br i1 [[C]], label [[LOOP_PREHEADER:%.*]], label [[EXIT:%.*]]
; CHECK:       loop.preheader:
; CHECK-NEXT:    [[TMP0:%.*]] = add i32 [[LIM]], 1
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[STOREMERGE:%.*]] = phi i32 [ [[INC:%.*]], [[LOOP]] ], [ 0, [[LOOP_PREHEADER]] ]
; CHECK-NEXT:    store i32 [[STOREMERGE]], i32* @a
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[STOREMERGE]], 1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp ne i32 [[INC]], [[TMP0]]
; CHECK-NEXT:    br i1 [[EXITCOND]], label [[LOOP]], label [[EXIT_LOOPEXIT:%.*]]
; CHECK:       exit.loopexit:
; CHECK-NEXT:    br label [[EXIT]]
; CHECK:       exit:
; CHECK-NEXT:    ret i32 0
;
entry:
  %c = icmp ult i32 %lim, -1
  br i1 %c, label %loop, label %exit

loop:
  %storemerge = phi i32 [ 0, %entry ], [ %inc, %loop ]
  store i32 %storemerge, i32* @a
  %cmp = icmp ult i32 %storemerge, %lim
  %inc = add nuw nsw i32 %storemerge, 1
  br i1 %cmp, label %loop, label %exit

exit:
  ret i32 0
}
