; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
; RUN: llc -mtriple aarch64 -O0 -aarch64-enable-atomic-cfg-tidy=0 -stop-after=irtranslator -global-isel -verify-machineinstrs %s -o - 2>&1 | FileCheck %s

define i32 @switch(i32 %argc) {
  ; CHECK-LABEL: name: switch
  ; CHECK: bb.1.entry:
  ; CHECK:   successors: %bb.3(0x40000000), %bb.6(0x40000000)
  ; CHECK:   liveins: $w0
  ; CHECK:   [[COPY:%[0-9]+]]:_(s32) = COPY $w0
  ; CHECK:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 100
  ; CHECK:   [[C1:%[0-9]+]]:_(s32) = G_CONSTANT i32 200
  ; CHECK:   [[C2:%[0-9]+]]:_(s32) = G_CONSTANT i32 2
  ; CHECK:   [[C3:%[0-9]+]]:_(s32) = G_CONSTANT i32 1
  ; CHECK:   [[C4:%[0-9]+]]:_(s32) = G_CONSTANT i32 0
  ; CHECK:   [[ICMP:%[0-9]+]]:_(s1) = G_ICMP intpred(eq), [[COPY]](s32), [[C]]
  ; CHECK:   G_BRCOND [[ICMP]](s1), %bb.3
  ; CHECK:   G_BR %bb.6
  ; CHECK: bb.6.entry:
  ; CHECK:   successors: %bb.4(0x40000000), %bb.2(0x40000000)
  ; CHECK:   [[ICMP1:%[0-9]+]]:_(s1) = G_ICMP intpred(eq), [[COPY]](s32), [[C1]]
  ; CHECK:   G_BRCOND [[ICMP1]](s1), %bb.4
  ; CHECK:   G_BR %bb.2
  ; CHECK: bb.2.default:
  ; CHECK:   successors: %bb.5(0x80000000)
  ; CHECK:   [[ADD:%[0-9]+]]:_(s32) = G_ADD [[COPY]], [[C4]]
  ; CHECK:   G_BR %bb.5
  ; CHECK: bb.3.case100:
  ; CHECK:   successors: %bb.5(0x80000000)
  ; CHECK:   [[ADD1:%[0-9]+]]:_(s32) = G_ADD [[COPY]], [[C3]]
  ; CHECK:   G_BR %bb.5
  ; CHECK: bb.4.case200:
  ; CHECK:   successors: %bb.5(0x80000000)
  ; CHECK:   [[ADD2:%[0-9]+]]:_(s32) = G_ADD [[COPY]], [[C2]]
  ; CHECK: bb.5.return:
  ; CHECK:   [[PHI:%[0-9]+]]:_(s32) = G_PHI [[ADD]](s32), %bb.2, [[ADD1]](s32), %bb.3, [[ADD2]](s32), %bb.4
  ; CHECK:   $w0 = COPY [[PHI]](s32)
  ; CHECK:   RET_ReallyLR implicit $w0
entry:
  switch i32 %argc, label %default [
    i32 100, label %case100
    i32 200, label %case200
  ]

default:
  %tmp0 = add i32 %argc, 0
  br label %return

case100:
  %tmp1 = add i32 %argc, 1
  br label %return

case200:
  %tmp2 = add i32 %argc, 2
  br label %return

return:
  %res = phi i32 [ %tmp0, %default ], [ %tmp1, %case100 ], [ %tmp2, %case200 ]
  ret i32 %res
}

define i32 @test_cfg_remap(i32 %in) {
  ; CHECK-LABEL: name: test_cfg_remap
  ; CHECK: bb.1.entry:
  ; CHECK:   successors: %bb.2(0x40000000), %bb.5(0x40000000)
  ; CHECK:   liveins: $w0
  ; CHECK:   [[COPY:%[0-9]+]]:_(s32) = COPY $w0
  ; CHECK:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 1
  ; CHECK:   [[C1:%[0-9]+]]:_(s32) = G_CONSTANT i32 57
  ; CHECK:   [[DEF:%[0-9]+]]:_(s32) = G_IMPLICIT_DEF
  ; CHECK:   [[C2:%[0-9]+]]:_(s32) = G_CONSTANT i32 42
  ; CHECK:   [[ICMP:%[0-9]+]]:_(s1) = G_ICMP intpred(eq), [[COPY]](s32), [[C]]
  ; CHECK:   G_BRCOND [[ICMP]](s1), %bb.2
  ; CHECK:   G_BR %bb.5
  ; CHECK: bb.5.entry:
  ; CHECK:   successors: %bb.3(0x40000000), %bb.4(0x40000000)
  ; CHECK:   [[ICMP1:%[0-9]+]]:_(s1) = G_ICMP intpred(eq), [[COPY]](s32), [[C1]]
  ; CHECK:   G_BRCOND [[ICMP1]](s1), %bb.3
  ; CHECK:   G_BR %bb.4
  ; CHECK: bb.2.next:
  ; CHECK:   successors: %bb.4(0x80000000)
  ; CHECK:   G_BR %bb.4
  ; CHECK: bb.3.other:
  ; CHECK:   $w0 = COPY [[DEF]](s32)
  ; CHECK:   RET_ReallyLR implicit $w0
  ; CHECK: bb.4.phi.block:
  ; CHECK:   [[PHI:%[0-9]+]]:_(s32) = G_PHI [[C]](s32), %bb.5, [[C2]](s32), %bb.2
  ; CHECK:   $w0 = COPY [[PHI]](s32)
  ; CHECK:   RET_ReallyLR implicit $w0
entry:
  switch i32 %in, label %phi.block [i32 1, label %next
                                    i32 57, label %other]

next:
  br label %phi.block

other:
  ret i32 undef

phi.block:
  %res = phi i32 [1, %entry], [42, %next]
  ret i32 %res
}

define i32 @test_cfg_remap_multiple_preds(i32 %in) {
  ; CHECK-LABEL: name: test_cfg_remap_multiple_preds
  ; CHECK: bb.1.entry:
  ; CHECK:   successors: %bb.3(0x40000000), %bb.6(0x40000000)
  ; CHECK:   liveins: $w0
  ; CHECK:   [[COPY:%[0-9]+]]:_(s32) = COPY $w0
  ; CHECK:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 1
  ; CHECK:   [[C1:%[0-9]+]]:_(s32) = G_CONSTANT i32 57
  ; CHECK:   [[C2:%[0-9]+]]:_(s32) = G_CONSTANT i32 128
  ; CHECK:   [[DEF:%[0-9]+]]:_(s32) = G_IMPLICIT_DEF
  ; CHECK:   [[C3:%[0-9]+]]:_(s32) = G_CONSTANT i32 12
  ; CHECK:   [[C4:%[0-9]+]]:_(s32) = G_CONSTANT i32 42
  ; CHECK:   [[ICMP:%[0-9]+]]:_(s1) = G_ICMP intpred(eq), [[COPY]](s32), [[C]]
  ; CHECK:   G_BRCOND [[ICMP]](s1), %bb.3
  ; CHECK:   G_BR %bb.6
  ; CHECK: bb.6.entry:
  ; CHECK:   successors: %bb.4(0x40000000), %bb.7(0x40000000)
  ; CHECK:   [[ICMP1:%[0-9]+]]:_(s1) = G_ICMP intpred(eq), [[COPY]](s32), [[C1]]
  ; CHECK:   G_BRCOND [[ICMP1]](s1), %bb.4
  ; CHECK:   G_BR %bb.7
  ; CHECK: bb.7.entry:
  ; CHECK:   successors: %bb.5(0x40000000), %bb.8(0x40000000)
  ; CHECK:   [[ICMP2:%[0-9]+]]:_(s1) = G_ICMP intpred(eq), [[COPY]](s32), [[C2]]
  ; CHECK:   G_BRCOND [[ICMP2]](s1), %bb.5
  ; CHECK:   G_BR %bb.8
  ; CHECK: bb.8.entry:
  ; CHECK:   successors: %bb.5(0x80000000)
  ; CHECK:   G_BR %bb.5
  ; CHECK: bb.2.odd:
  ; CHECK:   successors:
  ; CHECK: bb.3.next:
  ; CHECK:   successors: %bb.5(0x80000000)
  ; CHECK:   G_BR %bb.5
  ; CHECK: bb.4.other:
  ; CHECK:   $w0 = COPY [[DEF]](s32)
  ; CHECK:   RET_ReallyLR implicit $w0
  ; CHECK: bb.5.phi.block:
  ; CHECK:   [[PHI:%[0-9]+]]:_(s32) = G_PHI [[C]](s32), %bb.7, [[C]](s32), %bb.8, [[C4]](s32), %bb.3
  ; CHECK:   $w0 = COPY [[C3]](s32)
  ; CHECK:   RET_ReallyLR implicit $w0
entry:
  switch i32 %in, label %odd [i32 1, label %next
                              i32 57, label %other
                              i32 128, label %phi.block
                              i32 256, label %phi.block]
odd:
  unreachable

next:
  br label %phi.block

other:
  ret i32 undef

phi.block:
  %res = phi i32 [1, %entry], [1, %entry], [42, %next]
  ret i32 12
}

define i32 @jt_test(i32 %x) {
  ; CHECK-LABEL: name: jt_test
  ; CHECK: bb.1.entry:
  ; CHECK:   successors: %bb.4(0x40000000), %bb.5(0x40000000)
  ; CHECK:   liveins: $w0
  ; CHECK:   [[COPY:%[0-9]+]]:_(s32) = COPY $w0
  ; CHECK:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 71
  ; CHECK:   [[C1:%[0-9]+]]:_(s32) = G_CONSTANT i32 3
  ; CHECK:   [[C2:%[0-9]+]]:_(s32) = G_CONSTANT i32 42
  ; CHECK:   [[C3:%[0-9]+]]:_(s32) = G_CONSTANT i32 0
  ; CHECK:   [[C4:%[0-9]+]]:_(s32) = G_CONSTANT i32 4
  ; CHECK:   [[SUB:%[0-9]+]]:_(s32) = G_SUB [[COPY]], [[C4]]
  ; CHECK:   [[ZEXT:%[0-9]+]]:_(s64) = G_ZEXT [[SUB]](s32)
  ; CHECK:   [[ZEXT1:%[0-9]+]]:_(s64) = G_ZEXT [[C]](s32)
  ; CHECK:   [[ICMP:%[0-9]+]]:_(s1) = G_ICMP intpred(ugt), [[ZEXT]](s64), [[ZEXT1]]
  ; CHECK:   G_BRCOND [[ICMP]](s1), %bb.4
  ; CHECK: bb.5.entry:
  ; CHECK:   successors: %bb.3(0x2aaaaaab), %bb.4(0x2aaaaaab), %bb.2(0x2aaaaaab)
  ; CHECK:   [[JUMP_TABLE:%[0-9]+]]:_(p0) = G_JUMP_TABLE %jump-table.0
  ; CHECK:   G_BRJT [[JUMP_TABLE]](p0), %jump-table.0, [[ZEXT]](s64)
  ; CHECK: bb.2.sw.bb:
  ; CHECK:   successors: %bb.4(0x80000000)
  ; CHECK:   %11:_(s32) = nsw G_ADD [[COPY]], [[C2]]
  ; CHECK:   G_BR %bb.4
  ; CHECK: bb.3.sw.bb1:
  ; CHECK:   successors: %bb.4(0x80000000)
  ; CHECK:   %9:_(s32) = nsw G_MUL [[COPY]], [[C1]]
  ; CHECK: bb.4.return:
  ; CHECK:   [[PHI:%[0-9]+]]:_(s32) = G_PHI %9(s32), %bb.3, %11(s32), %bb.2, [[C3]](s32), %bb.1, [[C3]](s32), %bb.5
  ; CHECK:   $w0 = COPY [[PHI]](s32)
  ; CHECK:   RET_ReallyLR implicit $w0
entry:
  switch i32 %x, label %return [
    i32 75, label %sw.bb
    i32 34, label %sw.bb
    i32 56, label %sw.bb
    i32 35, label %sw.bb
    i32 40, label %sw.bb
    i32 4, label %sw.bb1
    i32 5, label %sw.bb1
    i32 6, label %sw.bb1
  ]

sw.bb:
  %add = add nsw i32 %x, 42
  br label %return

sw.bb1:
  %mul = mul nsw i32 %x, 3
  br label %return

return:
  %retval.0 = phi i32 [ %mul, %sw.bb1 ], [ %add, %sw.bb ], [ 0, %entry ]
  ret i32 %retval.0
}

define i32 @range_test(i32 %x) {
  ; CHECK-LABEL: name: range_test
  ; CHECK: bb.1.entry:
  ; CHECK:   successors: %bb.3(0x40000000), %bb.5(0x40000000)
  ; CHECK:   liveins: $w0
  ; CHECK:   [[COPY:%[0-9]+]]:_(s32) = COPY $w0
  ; CHECK:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 6
  ; CHECK:   [[C1:%[0-9]+]]:_(s32) = G_CONSTANT i32 24
  ; CHECK:   [[C2:%[0-9]+]]:_(s32) = G_CONSTANT i32 3
  ; CHECK:   [[C3:%[0-9]+]]:_(s32) = G_CONSTANT i32 42
  ; CHECK:   [[C4:%[0-9]+]]:_(s32) = G_CONSTANT i32 0
  ; CHECK:   [[ICMP:%[0-9]+]]:_(s1) = G_ICMP intpred(eq), [[COPY]](s32), [[C]]
  ; CHECK:   G_BRCOND [[ICMP]](s1), %bb.3
  ; CHECK:   G_BR %bb.5
  ; CHECK: bb.5.entry:
  ; CHECK:   successors: %bb.2(0x40000000), %bb.4(0x40000000)
  ; CHECK:   [[SUB:%[0-9]+]]:_(s32) = G_SUB [[COPY]], [[C1]]
  ; CHECK:   [[C5:%[0-9]+]]:_(s32) = G_CONSTANT i32 2
  ; CHECK:   [[ICMP1:%[0-9]+]]:_(s1) = G_ICMP intpred(ule), [[SUB]](s32), [[C5]]
  ; CHECK:   [[C6:%[0-9]+]]:_(s1) = G_CONSTANT i1 true
  ; CHECK:   [[XOR:%[0-9]+]]:_(s1) = G_XOR [[ICMP1]], [[C6]]
  ; CHECK:   G_BRCOND [[XOR]](s1), %bb.4
  ; CHECK:   G_BR %bb.2
  ; CHECK: bb.2.sw.bb:
  ; CHECK:   successors: %bb.4(0x80000000)
  ; CHECK:   %12:_(s32) = nsw G_ADD [[COPY]], [[C3]]
  ; CHECK:   G_BR %bb.4
  ; CHECK: bb.3.sw.bb1:
  ; CHECK:   successors: %bb.4(0x80000000)
  ; CHECK:   %10:_(s32) = nsw G_MUL [[COPY]], [[C2]]
  ; CHECK: bb.4.return:
  ; CHECK:   [[PHI:%[0-9]+]]:_(s32) = G_PHI %10(s32), %bb.3, %12(s32), %bb.2, [[C4]](s32), %bb.5
  ; CHECK:   $w0 = COPY [[PHI]](s32)
  ; CHECK:   RET_ReallyLR implicit $w0
entry:
  switch i32 %x, label %return [
    i32 24, label %sw.bb
    i32 25, label %sw.bb
    i32 26, label %sw.bb
    i32 6, label %sw.bb1
  ]

sw.bb:
  %add = add nsw i32 %x, 42
  br label %return

sw.bb1:
  %mul = mul nsw i32 %x, 3
  br label %return

return:
  %retval.0 = phi i32 [ %mul, %sw.bb1 ], [ %add, %sw.bb ], [ 0, %entry ]
  ret i32 %retval.0
}

